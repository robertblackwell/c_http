<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>http_in_c: Group_iobuffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">http_in_c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Group_iobuffer</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad9ea89310f25892e92afab591131dbaf"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structIOBuffer__s.html">IOBuffer_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gad9ea89310f25892e92afab591131dbaf">IOBuffer</a></td></tr>
<tr class="memdesc:gad9ea89310f25892e92afab591131dbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">IOBuffer as an opaque object.  <a href="group__group__iobuffer.html#gad9ea89310f25892e92afab591131dbaf">More...</a><br /></td></tr>
<tr class="separator:gad9ea89310f25892e92afab591131dbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373e47346d4021180e79668c7afcc0f5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structIOBuffer__s.html">IOBuffer_s</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga373e47346d4021180e79668c7afcc0f5">IOBufferRef</a></td></tr>
<tr class="separator:ga373e47346d4021180e79668c7afcc0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7ee96bb6c95938180ce94255b0226b77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga7ee96bb6c95938180ce94255b0226b77">IOBuffer_init</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this, int capacity)</td></tr>
<tr class="separator:ga7ee96bb6c95938180ce94255b0226b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5fd522d1f5f0392a23fb69f0ee252e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gabd5fd522d1f5f0392a23fb69f0ee252e">IOBuffer_new_with_capacity</a> (int capacity)</td></tr>
<tr class="memdesc:gabd5fd522d1f5f0392a23fb69f0ee252e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new IOBuffer with at least the requested capacity in bytes.  <a href="group__group__iobuffer.html#gabd5fd522d1f5f0392a23fb69f0ee252e">More...</a><br /></td></tr>
<tr class="separator:gabd5fd522d1f5f0392a23fb69f0ee252e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f691db670ded401154174d60e676db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga46f691db670ded401154174d60e676db">IOBuffer_new</a> ()</td></tr>
<tr class="memdesc:ga46f691db670ded401154174d60e676db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new IOBuffer with a a default capacity.  <a href="group__group__iobuffer.html#ga46f691db670ded401154174d60e676db">More...</a><br /></td></tr>
<tr class="separator:ga46f691db670ded401154174d60e676db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1fb2a389fa5d55d4f5ef6c558915aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga6a1fb2a389fa5d55d4f5ef6c558915aa">IOBuffer_from_cbuffer</a> (<a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf)</td></tr>
<tr class="memdesc:ga6a1fb2a389fa5d55d4f5ef6c558915aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an IOBuffer from the content of a Cbuffer by COPY.  <a href="group__group__iobuffer.html#ga6a1fb2a389fa5d55d4f5ef6c558915aa">More...</a><br /></td></tr>
<tr class="separator:ga6a1fb2a389fa5d55d4f5ef6c558915aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab006c3dae5dc9b9457a7404ddf79de75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gab006c3dae5dc9b9457a7404ddf79de75">IOBuffer_from_buf</a> (char *buf, int len)</td></tr>
<tr class="memdesc:gab006c3dae5dc9b9457a7404ddf79de75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an IOBUffer from the a pointer and length by COPY.  <a href="group__group__iobuffer.html#gab006c3dae5dc9b9457a7404ddf79de75">More...</a><br /></td></tr>
<tr class="separator:gab006c3dae5dc9b9457a7404ddf79de75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6960ab7d507273c6a9c4d5150b16195c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga6960ab7d507273c6a9c4d5150b16195c">IOBuffer_from_cstring</a> (char *cstr)</td></tr>
<tr class="memdesc:ga6960ab7d507273c6a9c4d5150b16195c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an IOBuffer from a c-string by COPY.  <a href="group__group__iobuffer.html#ga6960ab7d507273c6a9c4d5150b16195c">More...</a><br /></td></tr>
<tr class="separator:ga6960ab7d507273c6a9c4d5150b16195c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef4e2b7d22595e66f4a7beed0c33dce"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga8ef4e2b7d22595e66f4a7beed0c33dce">IOBuffer_cstr</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:ga8ef4e2b7d22595e66f4a7beed0c33dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a c string ref to internal data.  <a href="group__group__iobuffer.html#ga8ef4e2b7d22595e66f4a7beed0c33dce">More...</a><br /></td></tr>
<tr class="separator:ga8ef4e2b7d22595e66f4a7beed0c33dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0bd2a7d4f31a760c2f57c9337f99fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gacc0bd2a7d4f31a760c2f57c9337f99fc">IOBuffer_dup</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:gacc0bd2a7d4f31a760c2f57c9337f99fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an IOBuffer including copying the content to a new memory allocation.  <a href="group__group__iobuffer.html#gacc0bd2a7d4f31a760c2f57c9337f99fc">More...</a><br /></td></tr>
<tr class="separator:gacc0bd2a7d4f31a760c2f57c9337f99fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad546e42bad67049248f46ea7adbbbeb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gad546e42bad67049248f46ea7adbbbeb5">IOBuffer_set_used</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this, int bytes_used)</td></tr>
<tr class="separator:gad546e42bad67049248f46ea7adbbbeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2119d52c728825f9a3c8cba79d71dbd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga2119d52c728825f9a3c8cba79d71dbd5">IOBuffer_data</a> (const <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:ga2119d52c728825f9a3c8cba79d71dbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference pointer to the start of active data in the buffer. The memory pointed into is owned by the IoBuffer. Do not free.  <a href="group__group__iobuffer.html#ga2119d52c728825f9a3c8cba79d71dbd5">More...</a><br /></td></tr>
<tr class="separator:ga2119d52c728825f9a3c8cba79d71dbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6edf6065c3450a4302232d4f3948705c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga6edf6065c3450a4302232d4f3948705c">IOBuffer_data_len</a> (const <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:ga6edf6065c3450a4302232d4f3948705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a the length of active data in the buffer.  <a href="group__group__iobuffer.html#ga6edf6065c3450a4302232d4f3948705c">More...</a><br /></td></tr>
<tr class="separator:ga6edf6065c3450a4302232d4f3948705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7ff8dfa77edcac8a98a70ca470f168e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gac7ff8dfa77edcac8a98a70ca470f168e">IOBuffer_data_add</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this, <a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *p, int len)</td></tr>
<tr class="separator:gac7ff8dfa77edcac8a98a70ca470f168e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81bd07791efe1dab37c0b2f5f9db0ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga81bd07791efe1dab37c0b2f5f9db0ca7">IOBuffer_space</a> (const <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:ga81bd07791efe1dab37c0b2f5f9db0ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference pointer to the start of unused memory space after the last active content in the buffer. This is the start of a memory where more data could be placed. The memory pointed into is owned by the IoBuffer. Do not free.  <a href="group__group__iobuffer.html#ga81bd07791efe1dab37c0b2f5f9db0ca7">More...</a><br /></td></tr>
<tr class="separator:ga81bd07791efe1dab37c0b2f5f9db0ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad559ced27672766eb884a984a4acea20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gad559ced27672766eb884a984a4acea20">IOBuffer_space_len</a> (const <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:gad559ced27672766eb884a984a4acea20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a the length of available space in the buffer after the active data.  <a href="group__group__iobuffer.html#gad559ced27672766eb884a984a4acea20">More...</a><br /></td></tr>
<tr class="separator:gad559ced27672766eb884a984a4acea20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacc4c315c65aaf1aba3add49318dc09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gabacc4c315c65aaf1aba3add49318dc09">IOBuffer_commit</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this, int bytes_used)</td></tr>
<tr class="memdesc:gabacc4c315c65aaf1aba3add49318dc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the IoBuffer so that the bytes_used bytes of memory area after the active content is also considered to be active data. The memory addded is not updated as it is expected that data has already been added to that area.  <a href="group__group__iobuffer.html#gabacc4c315c65aaf1aba3add49318dc09">More...</a><br /></td></tr>
<tr class="separator:gabacc4c315c65aaf1aba3add49318dc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff18d332fc89d53d2835710db7f62ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gadff18d332fc89d53d2835710db7f62ef">IOBuffer_consume</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this, int byte_count)</td></tr>
<tr class="memdesc:gadff18d332fc89d53d2835710db7f62ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the IoBuffer so that the first byte_count bytes of the active data are now considered not active data. IE Increments the start pointer.  <a href="group__group__iobuffer.html#gadff18d332fc89d53d2835710db7f62ef">More...</a><br /></td></tr>
<tr class="separator:gadff18d332fc89d53d2835710db7f62ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad61012fc3fd189b4183aa1498dc5d829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gad61012fc3fd189b4183aa1498dc5d829">IOBuffer_free</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="separator:gad61012fc3fd189b4183aa1498dc5d829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec22bda9fa4e4e077be2667fe7b6743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gabec22bda9fa4e4e077be2667fe7b6743">IOBuffer_destroy</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="separator:gabec22bda9fa4e4e077be2667fe7b6743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acd7b485e5237f93f1e4f88d8380e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga3acd7b485e5237f93f1e4f88d8380e68">IOBuffer_reset</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:ga3acd7b485e5237f93f1e4f88d8380e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer back to empty without allocating new memory.  <a href="group__group__iobuffer.html#ga3acd7b485e5237f93f1e4f88d8380e68">More...</a><br /></td></tr>
<tr class="separator:ga3acd7b485e5237f93f1e4f88d8380e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59ba6628847ab2495ac906b480eb92f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#gad59ba6628847ab2495ac906b480eb92f">IOBuffer_consolidate_space</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:gad59ba6628847ab2495ac906b480eb92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make more space in the buffer. Without changing the overall capacity of the buffer There are two strategies used in this function: Strategy 1 - move used area to front of allocated memory When a buffer contains data but no space for new data this operation will move the active data to the front of the allocated memory and relase some memory for space for new data. Strategy 2 - when strategy 1 will not work expand the allocated memory space by doing a realloc.  <a href="group__group__iobuffer.html#gad59ba6628847ab2495ac906b480eb92f">More...</a><br /></td></tr>
<tr class="separator:gad59ba6628847ab2495ac906b480eb92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d0ada7e761acb176159f7b0f4a8d05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga09d0ada7e761acb176159f7b0f4a8d05">IOBuffer_empty</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:ga09d0ada7e761acb176159f7b0f4a8d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an IOBuffer and all its associated resources.  <a href="group__group__iobuffer.html#ga09d0ada7e761acb176159f7b0f4a8d05">More...</a><br /></td></tr>
<tr class="separator:ga09d0ada7e761acb176159f7b0f4a8d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e11c62c6155a0ff2ef21513a1efbd74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga8e11c62c6155a0ff2ef21513a1efbd74">IOBuffer_equal</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> a, <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> b)</td></tr>
<tr class="separator:ga8e11c62c6155a0ff2ef21513a1efbd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1e245e3e8c6707a6f8526af24285b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__iobuffer.html#ga8c1e245e3e8c6707a6f8526af24285b5">IOBuffer_memptr</a> (<a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> this)</td></tr>
<tr class="memdesc:ga8c1e245e3e8c6707a6f8526af24285b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the start of the buffers memory region.  <a href="group__group__iobuffer.html#ga8c1e245e3e8c6707a6f8526af24285b5">More...</a><br /></td></tr>
<tr class="separator:ga8c1e245e3e8c6707a6f8526af24285b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>IOBuffer is intended for:</p><ul>
<li>reading/writing data from/to say a socket and at the same time consuming some or all of the read data or producing more write data. The process would be something like:</li>
</ul>
<div class="fragment"><div class="line">bytes_read = read(fd, <a class="code" href="group__group__iobuffer.html#ga81bd07791efe1dab37c0b2f5f9db0ca7">IOBuffer_space</a>(<span class="keyword">this</span>), IOBUffer_space_len(<span class="keyword">this</span>);</div>
<div class="line"><a class="code" href="group__group__iobuffer.html#gabacc4c315c65aaf1aba3add49318dc09">IOBuffer_commit</a>(<span class="keyword">this</span>, bytes_read)</div>
<div class="line">bytes_processed = process_bytes(..... <a class="code" href="group__group__iobuffer.html#ga2119d52c728825f9a3c8cba79d71dbd5">IOBuffer_data</a>(<span class="keyword">this</span>). <a class="code" href="group__group__iobuffer.html#ga6edf6065c3450a4302232d4f3948705c">IOBuffer_data_len</a>(<span class="keyword">this</span>))</div>
<div class="line"><a class="code" href="group__group__iobuffer.html#gadff18d332fc89d53d2835710db7f62ef">IOBuffer_consume</a>(this, bytes_processed)</div>
<div class="ttc" id="agroup__group__iobuffer_html_ga2119d52c728825f9a3c8cba79d71dbd5"><div class="ttname"><a href="group__group__iobuffer.html#ga2119d52c728825f9a3c8cba79d71dbd5">IOBuffer_data</a></div><div class="ttdeci">void * IOBuffer_data(const IOBufferRef this)</div><div class="ttdoc">Returns a reference pointer to the start of active data in the buffer. The memory pointed into is own...</div><div class="ttdef"><b>Definition:</b> iobuffer.c:101</div></div>
<div class="ttc" id="agroup__group__iobuffer_html_ga6edf6065c3450a4302232d4f3948705c"><div class="ttname"><a href="group__group__iobuffer.html#ga6edf6065c3450a4302232d4f3948705c">IOBuffer_data_len</a></div><div class="ttdeci">int IOBuffer_data_len(const IOBufferRef this)</div><div class="ttdoc">Returns a the length of active data in the buffer.</div><div class="ttdef"><b>Definition:</b> iobuffer.c:106</div></div>
<div class="ttc" id="agroup__group__iobuffer_html_ga81bd07791efe1dab37c0b2f5f9db0ca7"><div class="ttname"><a href="group__group__iobuffer.html#ga81bd07791efe1dab37c0b2f5f9db0ca7">IOBuffer_space</a></div><div class="ttdeci">void * IOBuffer_space(const IOBufferRef this)</div><div class="ttdoc">Returns a reference pointer to the start of unused memory space after the last active content in the ...</div><div class="ttdef"><b>Definition:</b> iobuffer.c:121</div></div>
<div class="ttc" id="agroup__group__iobuffer_html_gabacc4c315c65aaf1aba3add49318dc09"><div class="ttname"><a href="group__group__iobuffer.html#gabacc4c315c65aaf1aba3add49318dc09">IOBuffer_commit</a></div><div class="ttdeci">void IOBuffer_commit(IOBufferRef this, int bytes_used)</div><div class="ttdoc">Updates the IoBuffer so that the bytes_used bytes of memory area after the active content is also con...</div><div class="ttdef"><b>Definition:</b> iobuffer.c:131</div></div>
<div class="ttc" id="agroup__group__iobuffer_html_gadff18d332fc89d53d2835710db7f62ef"><div class="ttname"><a href="group__group__iobuffer.html#gadff18d332fc89d53d2835710db7f62ef">IOBuffer_consume</a></div><div class="ttdeci">void IOBuffer_consume(IOBufferRef this, int byte_count)</div><div class="ttdoc">Updates the IoBuffer so that the first byte_count bytes of the active data are now considered not act...</div><div class="ttdef"><b>Definition:</b> iobuffer.c:156</div></div>
</div><!-- fragment --><div class="fragment"><div class="line">bytes_generated = output_generator( .... <a class="code" href="group__group__iobuffer.html#ga81bd07791efe1dab37c0b2f5f9db0ca7">IOBuffer_space</a>(<span class="keyword">this</span>), IOBUffer_spacelen(<span class="keyword">this</span>))</div>
<div class="line">IOBUffer_commit(this, bytes_generated)</div>
<div class="line">bytes_written = write(fd, <a class="code" href="group__group__iobuffer.html#ga2119d52c728825f9a3c8cba79d71dbd5">IOBuffer_data</a>(this), IOBuffer_datalen(this))</div>
<div class="line"><a class="code" href="group__group__iobuffer.html#gadff18d332fc89d53d2835710db7f62ef">IOBuffer_consume</a>(this, bytes_written)</div>
</div><!-- fragment --><p>NOTE: IOBuffers never expand - they can be made to have any capacity needed at creation time, there after they cannot expand. A consequence of this is that there re no "append" style methods.</p>
<p>It would be dangerous to allow a buffer to expand (and the address of the underlying memory possibly change) while the same buffer was being used for IO </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad9ea89310f25892e92afab591131dbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9ea89310f25892e92afab591131dbaf">&#9670;&nbsp;</a></span>IOBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structIOBuffer__s.html">IOBuffer_s</a> <a class="el" href="iobuffer_8c.html#ad9ea89310f25892e92afab591131dbaf">IOBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IOBuffer as an opaque object. </p>

</div>
</div>
<a id="ga373e47346d4021180e79668c7afcc0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373e47346d4021180e79668c7afcc0f5">&#9670;&nbsp;</a></span>IOBufferRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structIOBuffer__s.html">IOBuffer_s</a> * <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabacc4c315c65aaf1aba3add49318dc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabacc4c315c65aaf1aba3add49318dc09">&#9670;&nbsp;</a></span>IOBuffer_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> IOBuffer_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytes_used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the IoBuffer so that the bytes_used bytes of memory area after the active content is also considered to be active data. The memory addded is not updated as it is expected that data has already been added to that area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td></td></tr>
    <tr><td class="paramname">bytes_used</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad59ba6628847ab2495ac906b480eb92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad59ba6628847ab2495ac906b480eb92f">&#9670;&nbsp;</a></span>IOBuffer_consolidate_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> IOBuffer_consolidate_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make more space in the buffer. Without changing the overall capacity of the buffer There are two strategies used in this function: Strategy 1 - move used area to front of allocated memory When a buffer contains data but no space for new data this operation will move the active data to the front of the allocated memory and relase some memory for space for new data. Strategy 2 - when strategy 1 will not work expand the allocated memory space by doing a realloc. </p>

</div>
</div>
<a id="gadff18d332fc89d53d2835710db7f62ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadff18d332fc89d53d2835710db7f62ef">&#9670;&nbsp;</a></span>IOBuffer_consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> IOBuffer_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the IoBuffer so that the first byte_count bytes of the active data are now considered not active data. IE Increments the start pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td></td></tr>
    <tr><td class="paramname">byte_count</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ef4e2b7d22595e66f4a7beed0c33dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef4e2b7d22595e66f4a7beed0c33dce">&#9670;&nbsp;</a></span>IOBuffer_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* IOBuffer_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a c string ref to internal data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td>IOBuffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>c string Weak reference do not free </dd></dl>

</div>
</div>
<a id="ga2119d52c728825f9a3c8cba79d71dbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2119d52c728825f9a3c8cba79d71dbd5">&#9670;&nbsp;</a></span>IOBuffer_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>* IOBuffer_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference pointer to the start of active data in the buffer. The memory pointed into is owned by the IoBuffer. Do not free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* </dd></dl>

</div>
</div>
<a id="gac7ff8dfa77edcac8a98a70ca470f168e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7ff8dfa77edcac8a98a70ca470f168e">&#9670;&nbsp;</a></span>IOBuffer_data_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> IOBuffer_data_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6edf6065c3450a4302232d4f3948705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6edf6065c3450a4302232d4f3948705c">&#9670;&nbsp;</a></span>IOBuffer_data_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IOBuffer_data_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a the length of active data in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="gabec22bda9fa4e4e077be2667fe7b6743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabec22bda9fa4e4e077be2667fe7b6743">&#9670;&nbsp;</a></span>IOBuffer_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> IOBuffer_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd><ul>
<li>dont use </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc0bd2a7d4f31a760c2f57c9337f99fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc0bd2a7d4f31a760c2f57c9337f99fc">&#9670;&nbsp;</a></span>IOBuffer_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> IOBuffer_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate an IOBuffer including copying the content to a new memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td>IOBUfferRef </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IOBufferRef </dd></dl>

</div>
</div>
<a id="ga09d0ada7e761acb176159f7b0f4a8d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d0ada7e761acb176159f7b0f4a8d05">&#9670;&nbsp;</a></span>IOBuffer_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IOBuffer_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an IOBuffer and all its associated resources. </p>
<p>@Note: The argument is updated to NULL after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>IOBufferRef* </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e11c62c6155a0ff2ef21513a1efbd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e11c62c6155a0ff2ef21513a1efbd74">&#9670;&nbsp;</a></span>IOBuffer_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IOBuffer_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad61012fc3fd189b4183aa1498dc5d829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad61012fc3fd189b4183aa1498dc5d829">&#9670;&nbsp;</a></span>IOBuffer_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> IOBuffer_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only use when absolutely necessary. Frees the memory associated with 'this' but does not set pointer to NULL </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab006c3dae5dc9b9457a7404ddf79de75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab006c3dae5dc9b9457a7404ddf79de75">&#9670;&nbsp;</a></span>IOBuffer_from_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> IOBuffer_from_buf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an IOBUffer from the a pointer and length by COPY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>char* pointing to start of data to put in IOBUffer </td></tr>
    <tr><td class="paramname">len</td><td>int length of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IOBufferRef </dd></dl>

</div>
</div>
<a id="ga6a1fb2a389fa5d55d4f5ef6c558915aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a1fb2a389fa5d55d4f5ef6c558915aa">&#9670;&nbsp;</a></span>IOBuffer_from_cbuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> IOBuffer_from_cbuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an IOBuffer from the content of a Cbuffer by COPY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuf</td><td>CbufferRef </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IOBufferRef</dd></dl>
<p>WARNING - AT SOME POINT THIS FUNCTION WILL ACQUIRE MOVE SEMANTICS AND THE SOURCE Cbuffer will be left either A) consistent but EMPTY B) undefined - to do this we will need a new Cbuffer method called Cbuffer_steal_content needs more thinking about </p>

</div>
</div>
<a id="ga6960ab7d507273c6a9c4d5150b16195c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6960ab7d507273c6a9c4d5150b16195c">&#9670;&nbsp;</a></span>IOBuffer_from_cstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> IOBuffer_from_cstring </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an IOBuffer from a c-string by COPY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuf</td><td>CbufferRef </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IOBufferRef </dd></dl>

</div>
</div>
<a id="ga7ee96bb6c95938180ce94255b0226b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ee96bb6c95938180ce94255b0226b77">&#9670;&nbsp;</a></span>IOBuffer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> IOBuffer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8c1e245e3e8c6707a6f8526af24285b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1e245e3e8c6707a6f8526af24285b5">&#9670;&nbsp;</a></span>IOBuffer_memptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>* IOBuffer_memptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address of the start of the buffers memory region. </p>
<p>@Note: This is a dangerous function as it breaks the integrity of the IOBuffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td>IOBufferRef </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* </dd></dl>

</div>
</div>
<a id="ga46f691db670ded401154174d60e676db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f691db670ded401154174d60e676db">&#9670;&nbsp;</a></span>IOBuffer_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> IOBuffer_new </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new IOBuffer with a a default capacity. </p>
<dl class="section return"><dt>Returns</dt><dd>IOBufferRef </dd></dl>

</div>
</div>
<a id="gabd5fd522d1f5f0392a23fb69f0ee252e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd5fd522d1f5f0392a23fb69f0ee252e">&#9670;&nbsp;</a></span>IOBuffer_new_with_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a> IOBuffer_new_with_capacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new IOBuffer with at least the requested capacity in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>int The capacity of the new IOBuffer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IOBufferRef </dd></dl>

</div>
</div>
<a id="ga3acd7b485e5237f93f1e4f88d8380e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3acd7b485e5237f93f1e4f88d8380e68">&#9670;&nbsp;</a></span>IOBuffer_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> IOBuffer_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer back to empty without allocating new memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td>IOBufferRef </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad546e42bad67049248f46ea7adbbbeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad546e42bad67049248f46ea7adbbbeb5">&#9670;&nbsp;</a></span>IOBuffer_set_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> IOBuffer_set_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytes_used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga81bd07791efe1dab37c0b2f5f9db0ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81bd07791efe1dab37c0b2f5f9db0ca7">&#9670;&nbsp;</a></span>IOBuffer_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>* IOBuffer_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference pointer to the start of unused memory space after the last active content in the buffer. This is the start of a memory where more data could be placed. The memory pointed into is owned by the IoBuffer. Do not free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* </dd></dl>

</div>
</div>
<a id="gad559ced27672766eb884a984a4acea20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad559ced27672766eb884a984a4acea20">&#9670;&nbsp;</a></span>IOBuffer_space_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IOBuffer_space_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="iobuffer_8c.html#a373e47346d4021180e79668c7afcc0f5">IOBufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a the length of available space in the buffer after the active data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
