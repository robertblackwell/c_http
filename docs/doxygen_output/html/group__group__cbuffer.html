<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>http_in_c: Group_cbuffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">http_in_c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Group_cbuffer</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaec47cab3b4ddb0a70cdd57c84dd096e4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCbuffer__s.html">Cbuffer_s</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a></td></tr>
<tr class="separator:gaec47cab3b4ddb0a70cdd57c84dd096e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c9e663ed065fcd706a94d80a43f9bd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga3c9e663ed065fcd706a94d80a43f9bd3">Cbuffer_new</a> ()</td></tr>
<tr class="separator:ga3c9e663ed065fcd706a94d80a43f9bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb9967a22cf25835883f0ffceacccc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#gaeeb9967a22cf25835883f0ffceacccc2">Cbuffer_from_cstring</a> (const char *cstr)</td></tr>
<tr class="separator:gaeeb9967a22cf25835883f0ffceacccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25c5e584aae36f95aaf64dbb6b021448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga25c5e584aae36f95aaf64dbb6b021448">Cbuffer_free</a> (<a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf)</td></tr>
<tr class="separator:ga25c5e584aae36f95aaf64dbb6b021448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22458d15d3c523ca65d94ef1970292af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga22458d15d3c523ca65d94ef1970292af">Cbuffer_data</a> (const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> this)</td></tr>
<tr class="memdesc:ga22458d15d3c523ca65d94ef1970292af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a void* pointer to the start of the used portion of memory area.  <a href="group__group__cbuffer.html#ga22458d15d3c523ca65d94ef1970292af">More...</a><br /></td></tr>
<tr class="separator:ga22458d15d3c523ca65d94ef1970292af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26fbc35a40479fd2df1f172203a9ae9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#gab26fbc35a40479fd2df1f172203a9ae9">Cbuffer_cstr</a> (const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> this)</td></tr>
<tr class="memdesc:gab26fbc35a40479fd2df1f172203a9ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a char* pointer to the start of the used portion of memory area, the first byte after the used portion is always '\0' so that the pointer returned by this function is a valid c strin.  <a href="group__group__cbuffer.html#gab26fbc35a40479fd2df1f172203a9ae9">More...</a><br /></td></tr>
<tr class="separator:gab26fbc35a40479fd2df1f172203a9ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03bb642e5777dd332fbe1cccdf50d30"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#gad03bb642e5777dd332fbe1cccdf50d30">Cbuffer_size</a> (const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf)</td></tr>
<tr class="memdesc:gad03bb642e5777dd332fbe1cccdf50d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of used portion of the buffer.  <a href="group__group__cbuffer.html#gad03bb642e5777dd332fbe1cccdf50d30">More...</a><br /></td></tr>
<tr class="separator:gad03bb642e5777dd332fbe1cccdf50d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4642beff13ca198e9ac0a4c67483e2aa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga4642beff13ca198e9ac0a4c67483e2aa">Cbuffer_capacity</a> (const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf)</td></tr>
<tr class="memdesc:ga4642beff13ca198e9ac0a4c67483e2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current capacity of the buffer - max value of size, but.  <a href="group__group__cbuffer.html#ga4642beff13ca198e9ac0a4c67483e2aa">More...</a><br /></td></tr>
<tr class="separator:ga4642beff13ca198e9ac0a4c67483e2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39f2caaeec39de2835d36c40902b1a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#gaa39f2caaeec39de2835d36c40902b1a4">Cbuffer_next_available</a> (const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf)</td></tr>
<tr class="memdesc:gaa39f2caaeec39de2835d36c40902b1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the next available unused position in the buffer, which is always the '\0' terminator.  <a href="group__group__cbuffer.html#gaa39f2caaeec39de2835d36c40902b1a4">More...</a><br /></td></tr>
<tr class="separator:gaa39f2caaeec39de2835d36c40902b1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d71a06566eabad7af13e276575b2aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga2d71a06566eabad7af13e276575b2aca">Cbuffer_clear</a> (<a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> this)</td></tr>
<tr class="memdesc:ga2d71a06566eabad7af13e276575b2aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the buffer so that it is again an empty buffer. Does not release the manage memory area. If it has been expanded by previous usage pattern the larger memory area will be retained.  <a href="group__group__cbuffer.html#ga2d71a06566eabad7af13e276575b2aca">More...</a><br /></td></tr>
<tr class="separator:ga2d71a06566eabad7af13e276575b2aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf940ab747ab5ce42d52d24c9a86f1d42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#gaf940ab747ab5ce42d52d24c9a86f1d42">Cbuffer_append</a> (<a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf, <a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *data, size_t len)</td></tr>
<tr class="memdesc:gaf940ab747ab5ce42d52d24c9a86f1d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a block of data pointed at by a void* and of given the length to the used portion of the managed memory area. Expand the memory area using realloc if required.  <a href="group__group__cbuffer.html#gaf940ab747ab5ce42d52d24c9a86f1d42">More...</a><br /></td></tr>
<tr class="separator:gaf940ab747ab5ce42d52d24c9a86f1d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e99094e4005de89df141f380ffae65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga69e99094e4005de89df141f380ffae65">Cbuffer_append_cstr</a> (<a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf, const char *cstr)</td></tr>
<tr class="memdesc:ga69e99094e4005de89df141f380ffae65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data represented by the cstr argument to the used portion of the managed memory area. Expand the memory area using realloc if required.  <a href="group__group__cbuffer.html#ga69e99094e4005de89df141f380ffae65">More...</a><br /></td></tr>
<tr class="separator:ga69e99094e4005de89df141f380ffae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b8f93552c4444ef0a29c9386cd1e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#gae8b8f93552c4444ef0a29c9386cd1e4c">Cbuffer_set_size</a> (<a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf, size_t n)</td></tr>
<tr class="memdesc:gae8b8f93552c4444ef0a29c9386cd1e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the used size of the buffer to the given value.  <a href="group__group__cbuffer.html#gae8b8f93552c4444ef0a29c9386cd1e4c">More...</a><br /></td></tr>
<tr class="separator:gae8b8f93552c4444ef0a29c9386cd1e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214b4f22758d066f686b3e2f5b5f6d98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga214b4f22758d066f686b3e2f5b5f6d98">Cbuffer_move</a> (<a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> dest, <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> src)</td></tr>
<tr class="memdesc:ga214b4f22758d066f686b3e2f5b5f6d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the content of one Cbuffer instance to another by using move semantics. The internal pointers and counters of src are moved to dest.  <a href="group__group__cbuffer.html#ga214b4f22758d066f686b3e2f5b5f6d98">More...</a><br /></td></tr>
<tr class="separator:ga214b4f22758d066f686b3e2f5b5f6d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75d2be3cabfca3d16f4acb9469a1c6ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga75d2be3cabfca3d16f4acb9469a1c6ad">Cbuffer_contains_voidptr</a> (const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf, <a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *ptr)</td></tr>
<tr class="memdesc:ga75d2be3cabfca3d16f4acb9469a1c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detremines if an address value (pointer) is within the address range of the the buffer ie.  <a href="group__group__cbuffer.html#ga75d2be3cabfca3d16f4acb9469a1c6ad">More...</a><br /></td></tr>
<tr class="separator:ga75d2be3cabfca3d16f4acb9469a1c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga099759843ffecae3d2138fca0cd89914"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cbuffer.html#ga099759843ffecae3d2138fca0cd89914">Cbuffer_contains_charptr</a> (const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> cbuf, char *ptr)</td></tr>
<tr class="separator:ga099759843ffecae3d2138fca0cd89914"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A Cbuffer is a contiguous memory allocation that can expand as required. It maintains:</p><ul>
<li>the length of the total memory allocation,</li>
<li>the length of the used part of the memory allocation</li>
<li>always terminates the used portion with a '\0' which is not counted as part of the used portion so that the used portion is always a valid cstr </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaec47cab3b4ddb0a70cdd57c84dd096e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec47cab3b4ddb0a70cdd57c84dd096e4">&#9670;&nbsp;</a></span>CbufferRef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCbuffer__s.html">Cbuffer_s</a>* <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf940ab747ab5ce42d52d24c9a86f1d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf940ab747ab5ce42d52d24c9a86f1d42">&#9670;&nbsp;</a></span>Cbuffer_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> Cbuffer_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a block of data pointed at by a void* and of given the length to the used portion of the managed memory area. Expand the memory area using realloc if required. </p>
<p>@WARNING - THIS FUNCTION ALLOCATES MEMORY</p>
<p>The data being appended is copied so that the called retains ownership of and responsibility for the memory pointed to by the data argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuf</td><td>CbufferRef </td></tr>
    <tr><td class="paramname">data</td><td>void* </td></tr>
    <tr><td class="paramname">len</td><td>size_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga69e99094e4005de89df141f380ffae65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69e99094e4005de89df141f380ffae65">&#9670;&nbsp;</a></span>Cbuffer_append_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> Cbuffer_append_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the data represented by the cstr argument to the used portion of the managed memory area. Expand the memory area using realloc if required. </p>
<p>WARNING - THIS FUNCTION ALLOCATES MEMORY</p>
<p>The cstr must be a valid c string terminated by '\0'. The cstr is copied so that the called retains ownership of and responsibility for the memory pointed to by the cstr argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuf</td><td>CbufferRef </td></tr>
    <tr><td class="paramname">data</td><td>void* </td></tr>
    <tr><td class="paramname">len</td><td>size_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4642beff13ca198e9ac0a4c67483e2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4642beff13ca198e9ac0a4c67483e2aa">&#9670;&nbsp;</a></span>Cbuffer_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cbuffer_capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current capacity of the buffer - max value of size, but. </p>
<p>@Note: Cbuffer can be extended via realloc so the returned value of this function is not a constant</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuf</td><td>CbufferRef </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t</dd></dl>
<p>capacity of the buffer - max value of size </p>

</div>
</div>
<a id="ga2d71a06566eabad7af13e276575b2aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d71a06566eabad7af13e276575b2aca">&#9670;&nbsp;</a></span>Cbuffer_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> Cbuffer_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the buffer so that it is again an empty buffer. Does not release the manage memory area. If it has been expanded by previous usage pattern the larger memory area will be retained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td>CbufferRef</td></tr>
  </table>
  </dd>
</dl>
<p>Resets the buffer so that it is again an empty buffer </p>

</div>
</div>
<a id="ga099759843ffecae3d2138fca0cd89914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga099759843ffecae3d2138fca0cd89914">&#9670;&nbsp;</a></span>Cbuffer_contains_charptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cbuffer_contains_charptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga75d2be3cabfca3d16f4acb9469a1c6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75d2be3cabfca3d16f4acb9469a1c6ad">&#9670;&nbsp;</a></span>Cbuffer_contains_voidptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cbuffer_contains_voidptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detremines if an address value (pointer) is within the address range of the the buffer ie. </p>
<div class="fragment"><div class="line">    buffer.data() &lt; = ptr &lt; buffer.data() + buffer.capacity();</div>
<div class="line">or, should it be</div>
<div class="line">    buffer.data() &lt; = ptr &lt; buffer.data() + buffer.size();</div>
</div><!-- fragment --><p>Detremines if an address value (pointer) is within the address range of the the buffer ie buffer.dada() &lt; = ptr &lt; buffer.data() + buffer.capacity(); or, should it be buffer.dada() &lt; = ptr &lt; buffer.data() + buffer.size(); </p>

</div>
</div>
<a id="gab26fbc35a40479fd2df1f172203a9ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab26fbc35a40479fd2df1f172203a9ae9">&#9670;&nbsp;</a></span>Cbuffer_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cbuffer_cstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a char* pointer to the start of the used portion of memory area, the first byte after the used portion is always '\0' so that the pointer returned by this function is a valid c strin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td>CbufferRef The buffer, cannot be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* POinter to start of used portion of the managed memory area </dd></dl>

</div>
</div>
<a id="ga22458d15d3c523ca65d94ef1970292af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22458d15d3c523ca65d94ef1970292af">&#9670;&nbsp;</a></span>Cbuffer_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>* Cbuffer_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a void* pointer to the start of the used portion of memory area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">this</td><td>CbufferRef The buffer, cannot be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* POinter to start of used portion of the managed memory area</dd></dl>
<p>gets a pointer to the start of the memory slab being managed by the instance </p>

</div>
</div>
<a id="ga25c5e584aae36f95aaf64dbb6b021448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25c5e584aae36f95aaf64dbb6b021448">&#9670;&nbsp;</a></span>Cbuffer_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> Cbuffer_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the only method that can operate on an invalidated Cbuffer That is one who has had their memory stolen </p>

</div>
</div>
<a id="gaeeb9967a22cf25835883f0ffceacccc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb9967a22cf25835883f0ffceacccc2">&#9670;&nbsp;</a></span>Cbuffer_from_cstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> Cbuffer_from_cstring </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WARNING - THIS FUNCTION ALLOCATES MEMORY </p>

</div>
</div>
<a id="ga214b4f22758d066f686b3e2f5b5f6d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga214b4f22758d066f686b3e2f5b5f6d98">&#9670;&nbsp;</a></span>Cbuffer_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> Cbuffer_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the content of one Cbuffer instance to another by using move semantics. The internal pointers and counters of src are moved to dest. </p>
<p>src argument is reset to an empty buffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>CbufferRef </td></tr>
    <tr><td class="paramname">src</td><td>CbufferRef </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c9e663ed065fcd706a94d80a43f9bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c9e663ed065fcd706a94d80a43f9bd3">&#9670;&nbsp;</a></span>Cbuffer_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a> Cbuffer_new </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WARNING - THIS FUNCTION ALLOCATES MEMORY </p>

</div>
</div>
<a id="gaa39f2caaeec39de2835d36c40902b1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa39f2caaeec39de2835d36c40902b1a4">&#9670;&nbsp;</a></span>Cbuffer_next_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a>* Cbuffer_next_available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the next available unused position in the buffer, which is always the '\0' terminator. </p>
<p>Should not be used other than by Cbuffer functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuf</td><td>CbufferRef </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void*</dd></dl>
<p>returns a pointer to the next available unused position in the buffer </p>

</div>
</div>
<a id="gae8b8f93552c4444ef0a29c9386cd1e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8b8f93552c4444ef0a29c9386cd1e4c">&#9670;&nbsp;</a></span>Cbuffer_set_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rl__internal_8h.html#a691e4d5de4b427a20b12e6a256b5406e">void</a> Cbuffer_set_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the used size of the buffer to the given value. </p>
<p>Reserved for Cbuffer internal use. </p>

</div>
</div>
<a id="gad03bb642e5777dd332fbe1cccdf50d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad03bb642e5777dd332fbe1cccdf50d30">&#9670;&nbsp;</a></span>Cbuffer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cbuffer_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__group__cbuffer.html#gaec47cab3b4ddb0a70cdd57c84dd096e4">CbufferRef</a>&#160;</td>
          <td class="paramname"><em>cbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of used portion of the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbuf</td><td>CbufferRef </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t</dd></dl>
<p>gets the size of used portion of the buffer </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
