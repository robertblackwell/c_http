A runloop is a mechanism that allows a program to\+:
\begin{DoxyItemize}
\item wait for events associated with file descriptors,
\item run a callback function when such an event happens, and
\item schedule subsequent callbacks to run in the future
\end{DoxyItemize}

A runloop is the common method for structuring event driven programs.

\char`\"{}\+Runloop\char`\"{} is the name that Apple gives to the implementation underlying its user interface.

Other \char`\"{}runloops\char`\"{} have other names.

An \char`\"{}event loop\char`\"{} is what python amd nodejs call theirs.

In addition to thier use in GUI libraries they are common in programs that perform event-\/driven or asynchronous I/O, such a webservers and more generally network programs.

This directory (http\+\_\+in\+\_\+c/runloop) implements a \char`\"{}runloop\char`\"{} as the basis for building a simple event driven webserver.

\doxysection*{How is a runloop used}

A typical event-\/driven program looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{int main() }
\DoxyCodeLine{\{}
\DoxyCodeLine{    runloop\_t* = runloop\_new(....);}
\DoxyCodeLine{    }
\DoxyCodeLine{    ... do some setup -\/-\/ more details later}
\DoxyCodeLine{    ... and start something going like a no-\/wait read}
\DoxyCodeLine{    }
\DoxyCodeLine{    runloop\_run(rl);}
\DoxyCodeLine{    // the call on the previous line only returns when the program is over}
\DoxyCodeLine{\}}

\end{DoxyCode}


\doxysection*{Considerations}

The runloop presented here is based on the Linux {\bfseries{e-\/poll}} systems call and is hence not portable to other operating systems.

A central tool in building and using a runloop is the concept of a callback or closure. It is a function together with a context.

You the programmer must tell the runloop which \char`\"{}callback\char`\"{} to invoke for each of the events that can possibly be triggered; because {\bfseries{all}} events funnel through the {\ttfamily runloop}.

In the C language a callback is a pair consisting of a function pointer and an anonymous pointer (void$\ast$).

The pointer points at an instance of a {\ttfamily struct} which holds all the context data the function needs to operate.

This is a somewhat rigid way of providing closures and is one of the \char`\"{}features\char`\"{} that making writing event driven code C a bit tedious.

Typically, callbacks should be short and fast, should not perform long calculations and should not perform any synchronous I/O (like calling {\ttfamily printf()} or reading from a file). The whole point of the runloop is that

However, some operations cannot be made short and/or fast, and one runloop solution to this is a thread pool.

I have implemented a simple thread associated with the runloop in this directory.

Some runloops can be used by multiple threads (the C++ Boost library for example) and some cannot (libuv which is the basis of nodejs).

The runloop in this project is limited to a single thread. If you want multiple threads you need a runloop per thread. I might talk later about how to coordinate between threads and their separate runloops. 