=================================
The Runloop
=================================

A runloop is a mechanism that provides two functions:

* allows code to wait and be notified when a file descriptor is ready for input(POLLIN) or output(POLLOUT) or experiences an error.

     * allows a single OS thread to handle input/output for multiple file descriptors simultaniously.

     * Notification is through a callback mechanism. This is an example of the well known observer pattern.

*  a mechanism where by blocks of code (in our case functions) can be added to a queue of waiting blocks and be executed in its turn. 
This mechanism provides a lightweight form of multi-threading inside a single OS thread.

An important point to understand is that a runloop is a forever loop, once you call runloop_run()
it never returns. Before calling runloop_run() there must be some event handlers set up or callbacks
scheduled on the runloop using runloop_post() in order that stuff happens.

These two features are found in well known libraries such as __libuv__, __libevent__, and __boost::asio__.

A runloop is implemented as an opaque type __Runloop__, is almost always referenced via a pointer type __RunloopRef__.

A single instance of a Runloop can only be used by a single OS threads. There is an exception to this restriction
which will be discussed below.

.. doxygentypedef Runloop_s
.. doxygentypedef RunloopRef

.. docxygenfunction runloop_new
.. doxygen runloop_init
